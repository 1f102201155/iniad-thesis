\section{実行プロセスと生成物の変遷}
\label{sec:impl_process}

本節では，実装したシステムが実際にどのように機能するかを，具体的な家電操作シナリオを用いて検証する。
例題として，一般的な全自動洗濯機の「標準コースでの洗濯開始」操作を取り上げる。
対象とするマニュアルには，「電源ボタンを押し，表示が点灯するのを待ってから，スタートボタンを押す」という手順が記述されているものとする。

以下に，このタスクを処理する際のデータの変遷を，4 つのステップに分けて示す。

\subsection{Step 1: デバイスマップの作成 (Preparation)}

まず，開発者は \texttt{init-bot-map} コマンドを実行し，SwitchBot API から取得したデバイス一覧を基に \texttt{switchbot.map.json} の雛形を生成する。

次に，物理的に SwitchBot Bot を家電に取り付ける。
本実験における実際の設置状況を\textbf{図\ref{fig:bot_setup}}に示す。

\begin{figure}[tb]
  \centering
  \includegraphics[width=0.7\linewidth]{figures/washing_machine_sample_img.jpg}
  \caption{洗濯機への SwitchBot Bot 設置状況}
  \label{fig:bot_setup}
\end{figure}

続いて，この物理的な Bot とマニュアル上のボタン名の対応関係を定義ファイルに記述する（図\ref{fig:example_map}）。
この定義により，システムは「電源ボタン」というラベルを特定の物理デバイス ID に変換可能となる。

\input{figures/code_map_example}

\subsection{Step 2: マニュアル解析と IR 生成 (Analyzer)}
次に，マニュアルテキストと上記のマップを入力として\texttt{generate-doc} コマンドを実行する。
LLM はマニュアルの記述を解析し，「電源ボタンを押す」$\to$「スタートボタンを押す」というシーケンスを抽出する。
この結果は，以下のような中間表現 (IR) として構造化される。

\begin{itemize}
  \item \textbf{OpenAPI 定義 (\texttt{openapi.json})}:
  操作のエンドポイントとして \texttt{POST /washing-machine/start} が定義される。
  \item \textbf{操作フロー定義 (\texttt{switchbot\_flow.json})}:
  上記エンドポイントに対応する \texttt{operationId: "startMachine"} に対して，
  Fig.~\ref{fig:example_flow} に示すステップ配列が生成される。
\end{itemize}

\input{figures/code_flow_example}

\subsection{Step 3: コード生成と実装注入 (Synthesizer \& Injector)}
続いて，\texttt{generate-api} コマンドにより Flask サーバのスタブが生成され，
\texttt{implement} コマンドによって制御ロジックが注入される。
Injector は \texttt{switchbot\_flow.json} を読み込み，ラベル「電源ボタン」を物理 ID \texttt{"E16A82C65393"}等 に解決した上で，
Fig.~\ref{fig:example_code} のような Python コードをコントローラ内に展開する

\input{figures/code_py_example}

このプロセスは決定論的であり，生成されるコードは常に構文的に正しいことが保証される。

\subsection{Step 4: 実行と動作確認}
生成されたサーバを起動し，クライアントから \texttt{/washing-machine/start} にリクエストを送信すると，
プログラムは定義された順序に従って SwitchBot Cloud API を呼び出す。
その結果，物理空間にある 2 つの Bot が順次動作し，洗濯機のボタンが物理的に押下され，運転が開始される。

以上のプロセスにより，マニュアルの入力から物理デバイスの操作に至るまでの一連の流れが，
人手によるコーディングなしに自動化されていることが確認できる。
