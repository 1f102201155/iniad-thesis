\chapter{関連研究}

本章では，本研究の背景となる既存のアプローチと関連技術について整理する。
まず，(1) IoT システムにおける相互運用性確保の従来手法とその課題について述べ，
その解決策としての (2) LLM による API 仕様生成技術，
および (3) OpenAPI 仕様を用いたコード生成技術について概説する。
さらに，本研究で操作対象として採用する (4) 物理ボタン操作デバイスの制御技術についても触れる。
最後に，これらを踏まえた本研究の立ち位置について述べる。

% ---------------------------------------------------------
\section{IoTにおける相互運用性とインターフェース統合}

本研究の目的は多様な IoT 機器のインターフェースを統一的に扱うこと、
ひいては IoT 開発を高度な知識なく、簡単に実装可能にすることにある。
LLM を用いた自動生成のアプローチを論じる前に、
IoT の相互運用性（Interoperability）確保に関する従来のアプローチとその限界について整理する。

\subsection{標準化プロトコルによるアプローチ}
IoT 機器の断片化（Fragmentation）を解消するため、
通信プロトコルやデータモデルを標準化する取り組みが長年行われてきた。
国内においては ECHONET Lite、国際的には Matter などの
標準規格が策定されている\cite{ECHONETSpec,MatterSpec}。
これらの規格に準拠した機器同士であれば、事前の統合作業なしに相互操作が可能となる。

しかし、これらの標準化アプローチには「普及の壁」と「独自機能の欠落」という課題がある。
市場には標準規格に対応していないレガシー機器や、
コストの観点から独自の簡易なプロトコルを採用した機器が依然として多数存在する。
また、標準規格は汎用的な機能（ON/OFF や温度設定など）には対応できるが、
各メーカーが差別化のために搭載した独自機能（例：特定の快眠モードや AI 制御など）は
標準仕様の範囲外となり、結局は独自 API を利用せざるを得ないケースが多い\cite{SpaceCore2024}。

\subsection{IoT プラットフォームと手動統合}
プロトコルが異なる機器を統合するために、
Home Assistant や Eclipse SmartHome といった IoT プラットフォームが広く利用されている。
これらは「Binding」や「Integration」と呼ばれるドライバモジュールを介すことで、
HTTP、MQTT、Bluetooth などの異なるプロトコルを抽象化し、統一的な操作を可能にする。

しかし、これらの統合モジュールの開発は、コミュニティの開発者による手動実装に強く依存している。
新しい機器が発売されるたびに、専門知識を持つ開発者がマニュアルや通信パケットを解析し、
個別にコードを記述する必要があるため、
新製品への追従性やメンテナンスコストが大きなボトルネックとなっている\cite{SmartDev2024}。
この「手動実装」の壁が、IoT 開発の民主化を阻む要因となっている。

\subsection{Web of Things (WoT) と記述モデル}
W3C が推進する Web of Things (WoT) は、
Thing Description (TD) と呼ばれる JSON-LD 形式のメタデータを用いて
機器のインターフェースを記述し、Web 技術標準での統合を目指している。
WoT のアプローチは、機器の実装（プロトコル）とインターフェース記述を分離する点で
本研究の OpenAPI によるアプローチと親和性が高い。

しかし、既存の機器に対して適切な Thing Description を付与するためには、
やはり人間が仕様を理解し、記述を作成する必要がある。
本研究は、この「仕様記述の作成」という最も専門性を要する工程を、
LLM によるマニュアル読解によって自動化する試みとして位置づけられる。

% ---------------------------------------------------------
\section{LLMによる API 仕様生成}

前節で述べた「仕様記述コスト」の問題に対し、
近年では LLM を用いて API 仕様（OpenAPI）を自動生成する研究が活発に行われている。
本節ではオンラインドキュメント、コードなど異なる入力から OpenAPI を生成する手法を概説する。

\subsection{OASBuilder: Online API Documentation からの仕様生成}
OASBuilder\cite{OASBuilder2025} は，オンラインで公開されている API ドキュメントを入力として，
対応する OpenAPI 仕様書を自動生成することを目的とした手法である。
同一著者らによる先行研究 SpeCrawler\cite{SpeCrawler2023} も API ドキュメントを対象に
OpenAPI 仕様を生成する試みであったが，抽出結果の構造化や検証工程が限定的であり，
大規模な仕様では抜け漏れが生じやすいという課題があった。
OASBuilder はこれらの課題を踏まえ，より体系化された中間表現（IR）および検証フェーズを導入することで，
精度と信頼性を向上させている。

また、多くの商用 API ドキュメントは人間の閲覧を前提としており，HTML 構造や記述形式が統一されていないため，
LLM を直接適用すると項目の抜け漏れや不整合が生じやすい。
これに対して OASBuilder は，まず API ドキュメントから API 名称，パラメータ，レスポンス要素などを段階的に抽出し，
整理された中間表現（Intermediate Representation; IR）として統合する。
その後，IR を基に OpenAPI 仕様へ変換し，さらに生成結果を検証・修正する複数段階のパイプラインを採用している。

このように，長大で階層性の高い仕様情報を一度に生成せず，
\textbf{段階的抽出（decomposition）→構造化（IR）→仕様生成→検証}という逐次的な設計を導入することで，
LLM が不完全な情報から誤った JSON 構造を生成してしまう問題を緩和している。
特に IR の導入は，仕様生成を安定化させる上で重要な役割を果たし，
後続の整合性チェックやエラー修正も容易にする。
この点は，本研究において家電マニュアルとデバイスマップから IR を形成し，
OpenAPI Generator によるコード生成につなげるという構成とも共通しており，
OASBuilder は本研究のアプローチに近い先行研究といえる。

\subsection{LRASGen: ソースコードからの OpenAPI 生成}
LRASGen\cite{LRASGen2025} は，部分的なソースコードから RESTful API の振る舞いを推定し，
対応する OpenAPI 仕様を自動生成することを目的とした手法である。
既存の多くの API 仕様生成手法は，API ドキュメントやコメントを前提としており，
コード断片のみからエンドポイントやパラメータ，レスポンス構造を復元することは困難である。
LRASGenはこの課題に対し、ソースコードからエンドポイントメソッド，エンドポイントパラメータ，
パラメータ制約，エンドポイントレスポンスという四つのエンティティを段階的に同定し，
その結果に基づいて OpenAPI 仕様を生成するパイプラインを提案している。

LRASGen はコードベースのサービスに対して有効であり，
既存コードから API 仕様を後付けで構築する。
一方で，本研究が対象とする IoT 家電では公開ソースコードが提供されない場合が多く，
仕様生成はマニュアル記述や動作仕様など非構造的な情報から行う必要がある。
この点で LRASGen は入力ソースの性質が大きく異なり，
本研究のように説明文・機能一覧・デバイスマップから中間表現（IR）を構築し，
OpenAPI 仕様へ変換するアプローチとは方向性が異なる。
しかし，LRASGen が採用する「段階的抽出と LLM による仕様補完」という構成は，
構造化されていない入力から仕様を推定する際の一般的な設計指針として参考になる。

% ---------------------------------------------------------
\section{OpenAPI仕様からのコード生成}
巨大な OpenAPI 仕様を扱う研究として、LLM によるコード生成の自動化が検討されている。  
本研究では openapi-generator を用いてコード生成を行うため、LLM でコードまで生成する手法とは異なる立場を取る。


\subsection{LLMによる大規模 OpenAPI のコード生成}
大規模な OpenAPI 仕様からコード生成を行う研究として，
Pejcz らによる研究\cite{LargeOpenAPI_CodeGen2023}がある。
この研究では，コンテキスト長を超える規模の OpenAPI 仕様を
そのまま LLM に入力するのではなく，仕様を分割しつつ
プロンプトをオーケストレーションすることで，
REST API 実装コードを段階的に生成する手法を提案している。
本研究とは異なり，仕様生成からコード生成までを LLM が一貫して担う点に特徴があり，
OpenAPI Generator を用いて決定的にコード生成を行う本研究とは
役割分担の設計が異なる。

% ---------------------------------------------------------
\section{物理ボタン操作デバイスと制御 API}
\label{sec:switchbot_background}

本研究では，レガシー家電を含む多様な機器を物理的に制御する手段として，
SwitchBot 社のスマートホームデバイスを採用する。
本節では，そのハードウェア特性と制御 API の仕様について述べる。

\subsection{SwitchBot Bot の概要}
SwitchBot Bot（以下，Bot）\ref{fig:switchbot_bot_image}は，家電の物理スイッチやボタン付近に貼り付けて使用する
小型のロボットアームデバイスである\cite{SwitchBotBot}。
Bluetooth Low Energy (BLE) 通信によりスマホアプリやハブから制御され，
アームを動かして物理的にボタンを押下することで，
通信機能を持たない既存の家電（照明，炊飯器，給湯器など）を IoT 化することができる。

Bot には以下の 3 つの動作モードが存在する。
\begin{itemize}
  \item \textbf{プレスモード (Press Mode)}:
  「押して戻る」動作を行うモード。
  状態を持たないプッシュボタン（例: 炊飯器のスタートボタン）の操作に適している。
  \item \textbf{スイッチモード (Switch Mode)}:
  専用パーツを用いて「押す（ON）」と「引き上げる（OFF）」を行うモード。
  物理的な状態を持つロッカースイッチ（例: 壁の照明スイッチ）の操作に適している。
  \item \textbf{カスタムモード (Customize Mode)}:
    ON および OFF の操作コマンドに対して，それぞれ任意の動作シーケンス（アクションセット）を定義可能なモードである。
    1 つのアクションは複数の「ステップ」から構成され，各ステップには「押下時間」，「待機間隔」，「繰り返し回数」を指定することができる。
    これにより，長押しや連打といった複雑な物理操作パターンを実現する。
\end{itemize}

\begin{figure}
    \begin{center}
        \includegraphics[scale=0.2]{figures/SwitchBot_Bot_image.jpg}
    \end{center}
    \caption{SwitchBot Botの画像（SwitchBot Bot販売ページより引用）}
    \label{fig:switchbot_bot_image}
\end{figure}


\subsection{SwitchBot Cloud API}
SwitchBot 社は，同社製品をインターネット経由で制御するための Web API (SwitchBot Cloud API) を公開している\cite{SwitchBotCloudAPI}。
開発者は HTTP リクエスト（GET/POST）を送信することで，
デバイスの状態取得やコマンド送信を行うことができる。

Bot に対する制御コマンドは「操作」に特化しており，
「指定した ID の Bot を押す」という単純な命令を実行する。
ただし，Bot は物理的にボタンを押すことはできるが，
その結果として「家電が実際に動作したか（例: 炊飯が始まったか）」を検知するセンサは持たないため，
API からの制御は基本的に一方的なコマンド送信となる特性がある。

% ---------------------------------------------------------
\section{本研究との位置づけ}

以上の既存研究を踏まえると、以下の特徴が本研究の独自性につながる。

\begin{itemize}
  \item 家電マニュアルやデバイスマップから IR を生成し、OpenAPI 仕様を自動生成する点
  \item LLM は仕様生成（IR 形成）に限定し、コード生成は openapi-generator を利用するハイブリッド構成である点
  \item IoT デバイス操作に特化した API を自動生成し、実際の家電操作ドライバに統合する点
\end{itemize}

これらの点から、本研究は既存の仕様生成研究や IoT 自動化研究とは異なる独自の貢献を持つ。

