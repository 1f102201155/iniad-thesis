\chapter{提案手法}
\label{chap:proposed_method}

本章では，家電マニュアルから IoT 操作用 Web API および制御コードを自動生成するための提案手法について述べる。
本研究の核となるのは，大規模言語モデル（LLM）の柔軟な読解能力と，従来のアルゴリズムによる堅牢なコード生成を組み合わせた「ハイブリッド生成アプローチ」である。

\section{システム概要}
提案システムの全体処理フローを図\ref{fig:system_flow}に示す。
本システムは，入力として「家電の取扱説明書（PDF/テキスト）」および「デバイスマップ（物理デバイスとラベルの対応表）」を受け取り，
以下の 3 段階の処理を経て，最終的に動作可能な API サーバのソースコードを出力する。

\begin{enumerate}
  \item \textbf{マニュアル解析と中間表現（IR）の生成}:
  LLM を用いてマニュアルから操作に関する情報のみを抽出し，本システム独自の軽量な JSON フォーマット（中間表現）に構造化する。
  \item \textbf{仕様書と制御フローの合成}:
  生成された IR を基に，決定論的なアルゴリズムを用いて標準的な OpenAPI 仕様書（OAS）と，デバイス操作手順書（Flow 定義）を自動合成する。
  \item \textbf{コード生成と実装注入}:
  OpenAPI Generator を用いてサーバのスタブコード（Flask）を生成し，その内部に Flow 定義に基づいた制御ロジックを注入する。
\end{enumerate}

この構成により，LLM 特有の「幻覚（Hallucination）」や「構文エラー」のリスクを最小限に抑えつつ，
多様なフォーマットで記述されたマニュアルへの対応を実現している。

\begin{figure}[tb]
  \begin{center}
    \includegraphics[width=0.5\textwidth]{figures/application_overview.png}
  \end{center}
  \caption{}
  \label{fig:system_flow}
\end{figure}

\section{中間表現 (Intermediate Representation; IR) の導入}
\label{sec:ir_design}

既存の多くの手法では，LLM に直接 OpenAPI 仕様（YAML/JSON）を出力させようとする。
しかし，OpenAPI 仕様は非常に冗長であり，かつ厳密なスキーマ構造（ネストされたオブジェクトや参照定義）を持つため，
LLM が一貫して正しい構文を出力することは困難である。
特に，トークン長制約の中で巨大な仕様書を生成させると，JSON の閉じ括弧の欠落や，必須フィールドの省略といったエラーが多発する。

さらに，本研究における予備検討として，LLM に直接 OpenAPI 仕様（YAML）を生成させるアプローチを試みたところ，
マニュアルの自然言語記述に含まれる「:（コロン）」が適切にエスケープされず，
パースエラーが多発するという実用上の課題も確認された。

そこで本手法では，LLM の出力を API 構築に必要な\textbf{「最小限の情報」}に限定するアプローチをとる。
これを\textbf{中間表現（IR）}と定義する。
IR は以下の 3 つの要素のみを持つシンプルな JSON オブジェクトである。

\begin{itemize}
  \item \textbf{info}: API のタイトル。
  \item \textbf{operations}: API として公開すべき操作のリスト（エンドポイントパス，HTTP メソッド，操作 ID）。
  \item \textbf{flow}: 各操作 ID に対応する具体的なデバイス制御手順（ボタン操作の順序）。
\end{itemize}

パラメータ定義やレスポンス定義，エラーハンドリングといった「定型的な」情報は IR には含めず，
後段のプログラムで自動補完する設計とすることで，LLM の負荷を下げ，生成の安定性を向上させている。

\section{ハイブリッド生成プロセス}

\subsection{Phase 1: LLM による抽出 (Extraction)}
このフェーズでは，自然言語で記述されたマニュアルから IR を生成する。
ここでの LLM の役割は，新たな操作手順を作り出す「創造」ではなく，
マニュアルから必要な情報を抜き出す\textbf{「抽出」}と，
自然言語を機械可読な形式へ変換する\textbf{「構造化（マッピング）」}に限定される。

具体的には，マニュアルをテキストチャンクに分割して LLM に入力し，
「どのボタンを，どういう順序で押せば，どのような操作が実現できるか」という情報を抽出させる。
この際，以下の制約をプロンプトで与えることで，出力の品質を担保する。

\begin{itemize}
  \item \textbf{操作の限定}: 電源 ON/OFF やモード変更など，物理ボタンで操作可能な機能のみを抽出対象とし，状態確認（Status Polling）はSwitchBot Botでは実現できないため対象外とする。
  \item \textbf{ラベルの厳密一致}: 操作対象となるボタン名は，後述するデバイスマップに定義されたラベル（Valid Labels）と完全に一致させることを強制する。未知のラベルや，LLM が想像で作ったラベルの使用は禁止する。
\end{itemize}

\subsection{Phase 2: 決定論的合成 (Deterministic Synthesis)}
Phase 1 で生成された IR は，TypeScript で実装されたジェネレータによって処理され，以下の 2 つの成果物に変換される。
この変換プロセスはルールベースのアルゴリズムであり，LLM は介入しないため，常に構文的に正しい出力が保証される。

\begin{enumerate}
  \item \textbf{OpenAPI Specification (openapi.json/yaml)}:
  IR の \texttt{operations} リストに基づき，パスやメソッドを定義する。
  この際，正常系（200 OK）および異常系（401 Unauthorized, 503 Service Unavailable 等）のレスポンススキーマは，
  システム側で用意したテンプレートを全エンドポイントに一律で適用する。
  これにより，手動で記述するには手間のかかる厳密な API 定義を瞬時に生成できる。

  \item \textbf{操作フロー定義 (switchbot\_flow.json)}:
  IR の \texttt{flow} 部分を切り出し，アプリケーションが実行時に参照するための設定ファイルとして保存する。
  ここでは，API の \texttt{operationId} と，実際の物理ボタン操作（\texttt{press}, \texttt{on}, \texttt{off}）のマッピングが定義される。
\end{enumerate}

\subsection{Phase 3: コード生成 (Code Generation)}
生成された OpenAPI 仕様を入力として，OSS ツールである OpenAPI Generator を実行し，
Python (Flask) のサーバコードを生成する。
本研究では，生成されたコントローラコード（スタブ）に対し，
Phase 2 で生成したフロー定義を読み込んで実行する汎用的なドライバロジックを注入する。
これにより，開発者は一切のコーディングを行うことなく，マニュアルの内容を反映した IoT API サーバを手に入れることができる。

\section{デバイスマップによる物理抽象化}
第\ref{sec:switchbot_background}節で述べた通り，SwitchBot Bot と Cloud API を利用することで，
通信機能を持たないレガシー家電であっても，物理ボタンへの後付け設置によって API 経由での制御が可能となる。
本研究では，この「物理操作の API 化」という利点を活かすことで，
マニュアルから単に仕様書を作成するだけでなく，実際に物理デバイスを操作可能なシステムを構築する。

家電の種類やメーカーによって，操作に必要な SwitchBot デバイスの構成は異なる（例：物理ボタンを押す「ボット」，赤外線を飛ばす「ハブ」など）。
本手法では，これらの物理デバイス構成を \texttt{switchbot.map.json} という定義ファイルに抽象化して入力する。

しかし，マニュアルに記述されている「ボタン名（ラベル）」と，
実際の API 制御に必要な「デバイス ID」は直接対応していない。
そこで本手法では，両者を仲介する抽象化レイヤとして \textbf{「デバイスマップ」} を導入する。

\subsection{デバイスマップの定義構造}
デバイスマップ (\texttt{switchbot.map.json}) は，
家電の「機能的なラベル」と「物理的なデバイス情報」の対応関係を定義した JSON ファイルである。
このマップにより，以下の 2 点の抽象化を実現している。

\begin{enumerate}
  \item \textbf{ID の隠蔽とラベル解決}:
  LLM は「電源ボタン」「スタート」といった意味的なラベルのみを扱って操作フローを生成する。
  システムは実行時にこのマップを参照し，ラベルに対応する物理デバイス ID（例: \texttt{E16A82C65393}）へと変換する。
  これにより，LLM の出力は特定のハードウェア環境に依存しない汎用的なものとなる。

  \item \textbf{動作モードの制約}:
  各デバイスに対して，第\ref{sec:switchbot_background}節で説明した Bot の動作モード
  (\texttt{pressMode} / \texttt{switchMode}) をマップ上で定義する。
  システムはこの定義に基づき，LLM が生成した操作タイプ（\texttt{press} なのか \texttt{on/off} なのか）が
  物理的に実行可能であるかを検証（バリデーション）する。
\end{enumerate}
