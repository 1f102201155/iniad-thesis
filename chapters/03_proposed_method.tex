\chapter{提案手法}
\label{chap:proposed_method}

本章では，家電マニュアルから IoT 操作用 Web API および制御コードを自動生成するための提案手法について述べる。
本研究の核となるのは，大規模言語モデル（LLM）の柔軟な読解能力と，従来のアルゴリズムによる堅牢なコード生成を組み合わせた「ハイブリッド生成アプローチ」である。

\section{システム概要}
本システムの全体処理フローを図\ref{fig:system_flow}に示す。
本システムは，入力として「家電の取扱説明書（PDF/テキスト）」および「デバイスマップ（物理デバイスとラベルの対応表）」を受け取り，
以下の 3 段階の処理を経て，最終的に動作可能な API サーバのソースコードを出力する。

\begin{enumerate}
  \item \textbf{マニュアル解析と中間表現（IR）の生成}:
  LLM を用いてマニュアルから操作に関する情報のみを抽出し，本システム独自の軽量な JSON フォーマット（中間表現）に構造化する。
  \item \textbf{仕様書と制御フローの合成}:
  生成された IR を基に，決定論的なアルゴリズムを用いて標準的な OpenAPI 仕様書（OAS）と，デバイス操作手順書（Flow 定義）を自動合成する。
  \item \textbf{コード生成と実装注入}:
  OpenAPI Generator を用いてサーバのスタブコード（Flask）を生成し，その内部に Flow 定義に基づいた制御ロジックを注入する。
\end{enumerate}

\begin{figure}[tb]
  \begin{center}
    \includegraphics[scale=0.3]{figures/application_overview.jpg}
  \end{center}
  \caption{提案システムフロー}
  \label{fig:system_flow}
\end{figure}

この構成により，LLM 特有の「幻覚（Hallucination）」や「構文エラー」のリスクを最小限に抑えつつ，
多様なフォーマットで記述されたマニュアルへの対応を実現している。

\section{デバイスマップによる物理抽象化}
第\ref{sec:switchbot_background}節で述べた通り，物理操作デバイス（SwitchBot Bot）を利用することで，
通信機能を持たない非スマート家電であっても，物理ボタンへの後付け設置によって API 経由での制御が可能となる。

しかし，マニュアルに記述されている「電源」「スタート」といった自然言語による\textbf{「ボタン名称」}と，
実際の API 制御に必要な\textbf{「物理デバイス ID」}（一意な識別子）の間には直接的な関連性がない。
LLM がマニュアルから抽出した操作手順を，特定の物理デバイスへの命令として実行するためには，
この両者を意味的に結びつける仕組みが必要となる。

そこで本手法では，両者を仲介する抽象化レイヤとして \textbf{「デバイスマップ」} を導入する。

\subsection{意味的ラベルと物理 ID の対応付け}
デバイスマップは，家電上の「機能的なボタン名称」と「物理的なデバイス情報」の対応関係を定義したものである。
このマップを導入することで，以下の 2 点の抽象化を実現する。

\begin{enumerate}
  \item \textbf{ID の隠蔽と名称解決}:
  LLM は複雑な「物理デバイス ID」を意識することなく，マニュアル上の「ボタン名称」のみを扱って操作フローを生成する。
  システムはコード生成時にこのマップを参照し，抽象的なボタン名称を具体的な物理デバイス ID へと変換（解決）する。
  これにより，LLM の出力は特定の個体や環境に依存しない汎用的なものとなる。

  \item \textbf{動作モードの制約}:
  各ボタンに対して，物理デバイスとしての動作モード（単一の「押下」のみか，状態を持つ「ON/OFF」か）を定義する。
  システムはこの定義に基づき，LLM が抽出した操作が物理的に実行可能であるかを検証し，ハードウェア仕様と矛盾がある場合は生成を中断するなどの整合性チェックを行う。
\end{enumerate}

\section{中間表現 (Intermediate Representation; IR) の導入}
\label{sec:ir_design}

既存の多くの手法では，LLM に直接 OpenAPI 仕様（YAML/JSON）を出力させようとする。
しかし，OpenAPI 仕様は非常に冗長であり，かつ厳密なスキーマ構造（ネストされたオブジェクトや参照定義）を持つため，
LLM が一貫して正しい構文を出力することは困難である。

そこで本手法では，LLM の出力を API 構築に必要な\textbf{「最小限の情報」}に限定するアプローチをとる。
これを\textbf{中間表現（IR）}と定義する。
IR は以下の 3 つの要素のみを持つシンプルな構造体である。

\begin{itemize}
  \item \textbf{info}: API のタイトル。
  \item \textbf{operations}: API として公開すべき操作のリスト（エンドポイントパス，HTTP メソッド，操作 ID）。
  \item \textbf{flow}: 各操作 ID に対応する具体的なデバイス制御手順（ボタン操作の順序）。
\end{itemize}

パラメータ定義やレスポンス定義，エラーハンドリングといった「定型的な」情報は IR には含めず，
後段のプログラムで自動補完する設計とすることで，LLM の負荷を下げ，生成の安定性を向上させている。

\section{ハイブリッド生成プロセス}

本節では，提案手法の中核をなす「ハイブリッド生成プロセス」の詳細について述べる。
本プロセスは，LLM による非決定的な情報抽出（Phase 1）と，アルゴリズムによる決定論的なコード合成（Phase 2, 3）を明確に分離・結合したパイプラインとして設計されている。

全体は以下の 3 つのフェーズによって構成され，各フェーズの出力が次フェーズの入力となることで，非構造データ（マニュアル）から構造化データ（IR），そしてプログラムコードへの段階的な変換を実現する。

\begin{itemize}
  \item \textbf{Phase 1 (Extraction)}: LLM がマニュアルから操作情報を抽出し，中間表現（IR）を生成する。
  \item \textbf{Phase 2 (Synthesis)}: IR を基に，API 仕様書と操作フロー定義を決定論的に合成する。
  \item \textbf{Phase 3 (Code Generation)}: API 仕様書からスタブコードを生成し，そこに操作ロジックを注入する。
\end{itemize}

以下，各フェーズの具体的な処理内容について述べる。

\subsection{Phase 1: LLM による抽出 (Extraction)}
このフェーズでは，自然言語で記述されたマニュアルから IR を生成する。
ここでの LLM の役割は，新たな操作手順を作り出す「創造」ではなく，
マニュアルから必要な情報を抜き出す\textbf{「抽出」}と，
自然言語を機械可読な形式へ変換する\textbf{「構造化（マッピング）」}に限定される。

具体的には，マニュアルを入力として，「どのボタンを，どういう順序で押せば，どのような操作が実現できるか」という情報を抽出させる。
生成される中間表現（IR）の構造例を図 \ref{fig:flow_example_compact} に示す。
この際，デバイスマップに定義された「ボタン名称」と完全に一致するラベルを使用するよう制約を課すことで，
後続処理での名称解決を確実にしている。

\input{figures/code_flow_compact}

\subsection{Phase 2: 決定論的合成 (Deterministic Synthesis)}
Phase 1 で生成された IR は，決定論的なアルゴリズムによって処理され，以下の 2 つの成果物に変換される。
ここでは LLM は介入しないため，常に構文的に正しい出力が保証される。

\begin{enumerate}
  \item \textbf{OpenAPI Specification}:
  IR の操作リストに基づき，標準的な REST API 定義（パス，メソッド，レスポンス定義）を生成する。
  正常系および異常系のレスポンススキーマは，システム側で用意したテンプレートを一律で適用する。

  \item \textbf{操作フロー定義}:
  IR のフロー部分を切り出し，アプリケーションが参照するための内部形式に変換する。
  これは，API が提供する\textbf{「ある操作」}を実行する際に，
  \textbf{「どのボット」}を\textbf{「どの順序」}で操作すればよいかを具体的に定義したものである。
\end{enumerate}

\subsection{Phase 3: コード生成 (Code Generation)}
最終段階として，生成された OpenAPI 仕様を入力としてサーバコード（スタブ）を生成し，
そこに操作フロー定義に基づいた具体的な制御ロジックを注入する。

一般的な API スタブ生成ツールは外枠のコードしか作成しないが，
本手法では，Phase 2 で確定した操作フロー（ボタン名称と順序）を物理デバイスへの命令（ID 指定とコマンド送信）に変換し，
実行可能なプログラムコードとして埋め込む。
これにより，開発者は一切のコーディングを行うことなく，マニュアルの内容を反映した IoT API サーバを構築することができる。
